- https://www.cs.cmu.edu/~softagents/
	- https://www.cs.cmu.edu/~softagents/mas_interop.html
	- https://www.cs.cmu.edu/~softagents/multi.html
		- An MAS has the following advantages over a single agent or centralized approach:
			- An MAS allows for the interconnection and interoperation of multiple existing legacy systems. By building an agent wrapper around such systems, they can be inporporated into an agent society.
			- An MAS models problems in terms of autonomous interacting component-agents, which is proving to be a more natural way of representing task allocation, team planning, user preferences, open environments, and so on.
	- Agent discovery infra https://www.cs.cmu.edu/~softagents/papers/infrastructureDiscovery.pdf
- https://github.com/trailblazer/trailblazer-workflow/blob/master/lib/trailblazer/workflow/collaboration/state_guards.rb
- https://github.com/langchain-ai/open-agent-platform
	- https://open-agent-platform.vercel.app/ Start chat: approach Agent rather than LLM.
- https://github.com/modelcontextprotocol/modelcontextprotocol/discussions/102 State, and long-lived vs. short-lived connections
	- "MCP is currently a _stateful_ protocol, with a long-lived connection between client and server. This allows us to support behaviors like:"
- https://github.com/orgs/i-am-bee/discussions/284
- Agentic AI: there should be a concept, special agent. For instance, the government assigns a special agent to deal with some crisis, some will call it is crisis-agent or crisis department. But this concept is more about privilege and coordinates more than functional. So beside, tool and function, there should be special privilege on functions, when an agent has a power to direct others.
	- It means handsoff and guardrails has to be customisable and eval like metaprogramming as well.
	- Agent can create agent as well, for that purpose the workflow must be fluid and tools must be declarative and accessible.
	- Anyway, the architectural decisions in developing agents are not crucial, both OpenAI and Anthropic suggest going with simple stuff first, then extending to the next form later. It is not a refactoring by design but only changing some concepts.
	- As an engineer, I don't think of using agents. We engineers should think about creating agents, creating the creation of agents, creation of the last creation.
	- The LLMs will continue to get better, it will digest the tools, one day. Coding -> it can execute the code internally because of something is implementing right at its model. We are training them the next piece of data: actions in real world, these actions are just data and code.