- a half `dry-rb` adoption is more confusing. Code are not being reused, flows are not clean and straightforward; we don't know how the code are related to each other through transaction `step` and registry/container/effect `deps`. If we knew it, is it a better way to work with business requirements, or just for visualisation and enough?
	- What should be:
		- contract/validation through `dry-schema`, `dry-monads` in error handling in controller
		- flow in the first business wrapper layer with dry-transaction in `app/transactions`, operations is not a flow, should be creational (CUD) or behavioral, returns monads result
			- eliminate callbacks, make callback operations rely on traditional operations, so suboperation and sideoperation beside main_operation
			- we have to think about operation like drawing a business step, stick to that mindset, it is hard to work on unknown businesses with operations.
		- dry-structs to enforce typing, if you care about strict argument
	- Then eventually it is hamanirb, this is what you should read for the authors' basic ideas https://hanamimastery.com/episodes/50-hanami-core-team-interview#question-1--what-problem-hanami-solves
		- https://hanamimastery.com/episodes/50-hanami-core-team-interview#question-7-hanami-and-business-logic-relation-to-trailblazer
		- https://hanamimastery.com/episodes/50-hanami-core-team-interview#question-7-hanami-and-business-logic-relation-to-trailblazer:~:text=When%20you%20combine%20the%20Deps%20mix
	- It is hard to change mindset, but a real learning journey should be like returning back to where it started: "duck-typing", as long as it works; and with some philosophies: how to think deeply about the way we make something like that.
	- https://fsharpforfunandprofit.com/posts/against-railway-oriented-programming/ "please don't take it to extreme" - there is no silver bullet, the adoption of Railway is not similar to taking a holy grail. Downside impacts can be (1) less performance due to overhead (2) lack of error resolution, (3) lack of backtrace. The author says it is truly "chaining functions" when it is NOT used thoughtlessly (üëç for domain modeling, to expect the likely happening errors) (üëé instead of coercing unexpected errors, making unnecessary abstractions). Do you think we need "chaining functions"? Do we possess the mindset of being "functional" aka "very generic"? Do you think OOP is a bad invention?
		- Let me answer: it depends, but if we haven't put these questions into our mind, we literally have no idea what we are doing. Don't be just cool, it is being a jerk.
		- https://twitter.com/scottwlaschin/status/997009818329198592 "In fact, I may have created a monster :)"